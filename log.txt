с чего начать..

1. HP
2. Дневные задания.

ХП зависит от выполнения задания.

все заметки храняться в obsidian, программа лишь исполняет скрипты, которые я обычно делаю руками.

для начала определим коды для каждого элемента в игре.


от 1 до 1000 - персонажи
от 1000 до 2000 - инструменты

у меня есть инвентарь, есть магазин.

из магазина в инвентарь, а из инвентаря в магазин.

от этих операций меняется лишь кол-во валюты.

каждый инструмент при создании получает уникальный id.

также и с персонажами.

для начала стоит создать базу данных.

с каждым оборотом цикла, будет обнавляться данные профиля.

вывод профиля происходит сам.

я добавил класс профиль.

Теперь вопрос, а зачем мне нужны другие персонажи если они никак сейчас не меняют мои характеристики ? ((

у каждого персонажа должно быть что-то особенное, чего нет у других.

возможно добавлю навык - талант - это то чем один персонаж отличается от другого.

Нужно ещё добавить меню

как сделать меню как в некоторых терминальных приложениях?

Обычно, там просто список пронумерованный.

Реализую магазин.

В магазине просто проводишь транзакцию, выбрал товар - ИД - выбираешь продать или купить в начале.

также стоит учесть что каждое изменение баланса, это обязательное внесение в историю.

по задумки, мой класс заполняется исходя из файла текстового, в котором сохранены все параметры персонажа и прч.

нужно определиться, что будет сохраняться в файл, а что нет.

весь профиль точно будет.

меню магазина тоже не является статичным значением, его тоже требуется сохранить.

нужно реализовать хранилище в котором будет храниться id товара и его стоимость.

товаром считается инструменты.

также нужен метод который будет проводить транзакции.

как выглядит транзакция?

купить:
market.del()

...

Если я удалю товар с магазина, то потеряю его.

Но как это обьясняется?

Товар распродан..

а как тогда мне тогда восстанавливать товар?

регулировать цены?

как добавлять асортимент?

Потому что к кошельку или к HP я доступа не имею.

Т.е, при покупки товара, его свойства должны быть применены.

Что усложняет работу с товаром..

Тогда товар и персонажи, это не просто добавить удалить ID.

Как я могу влиять на свои характеристики? На профиль?

только через инвентарь.

Покупка и продажа, это просто перетасовка IDшников.

Только работа через инвентарь, позваляет менять характеристики.

Добавлять товар можно, но я думаю спец карту для этого создать.

Карта, это типа фича, награда, которую тоже можно купить.

Карта, это рандомный ключ, он известен лишь продавцу. Его действие, кончиться через какое-то время.

Для этого нужен таймер.

Либо можно сделать не время, а кол-во раз.

Карта должна автоматически создаваться в магазине.

Если в магазине товар будет автоматически пересоздаваться, то я не буду успевать менять ассортимент в obsidian.

Obsidian - это фронтенд, а бэкенд программа.

Предлагаю просто сделать просто массив, в который товар добавляется и убавляется.

Сложные замки и прч, ставить не нужно!

А как же инвентарь? В нем позиции меняются автоматически.

Инвентарь будет лишь виртуальный.

Реальный инвентарь в программе, доступен лишь через терминал.

При покупки товара из магазина, мирное пополняет инвентарь.

Продавая товар в магазин, мы удаляем предмет из инвесторя, а магазин пополняем.

Цена на перепроданный товар должна падать.

Также я думаю, следует сделать класс «продавец».

Нет необходимости.

У магазина будет кошелек ETO.

inventory = [] # tool_id : ETO

Покупка:
Добавить товар в инвентарь. Снизив его стоимость - отнять -1/2 часть от стоимости.
Убрать товар из магазина.
Убавить у игрока монет.
Добавить магазину монет.

Продажа:
Забрать товар из инвентаря.
Добавляем монет игроку в размере стоимости указанной на товаре.
Добавить товар в магазин. Помножаем цену на 2 и это ценник у товара.
Убавить магазину монет на ту стоимость что была отдана игроку.

как будет выглядить инвентарь и магазин?

В целом, в obsidian я оставлю лишь карточки оружия и карточки персонажей.

Магазин также оставлю, но там будет лишь карточки товаров и ID, по которому его в терминале можно посмотреть.

в магазине не просто ID товара должен быть, а также характеристики.

ведь система также будет прибавлять или убавлять урон.

я бы предложил изначальную строку характеристик.

не зря же я её писал.

значит ID будет состоять из набора характеристик.

Дробовик - shotgun_dmg300

По сути мне нужно стамину как расчитать я хз.

я же её и для врагов расчитал..

может мне для врага стамину не считать?

пусть у врага будет лишь урон и HP и Armor..

защита также должна быть.

я думаю не заморачиваться и сделать также как Habitica.

а там нету кроме хп и урона ничего, ярость какая-то была..

Стоит сделать равные силы, врага и мои.

Для чего нужна выносливость?

Её можно использовать в качестве ограничителя, чтобы бой сказкой не казался.

предлагаю сделать модуль питона, в котором всё это будет прописано.

будет класс врага и мой класс.

будет инструмент, который будет у меня и у врага, 

class Human:
    HP = 100
    armor = 0
    strong = 1 # из 15
    intellect = 1 # из 15
    
при таком раскладе, инструмент становиться достаточно обьёмным.

хп это ясно.
защита - это ясно.
сила - влияет на что? на то смогу ли я потянуть иснтрумент зависящий от силы или нет.
интеллект - влияет на возможность использовать инструменты. Также на опыт получаемый от прохождений заданий.

мне нужна ячейка куда будут экиперовываться предметы.

даже не смотря на изменения в условии использования инструментов, покупка и продажа инструментов сложнее не стала.

Но вот отображать товар в магазине станет чуть сложнее.

пока что оставлю так как есть, просто отобразит ID.

Дробовик - shotgun_d300_s2_i1

из этого следует, что нужен метод который отвечает за процесс экипировки инструментов.

отразиться ли вышеперечисленное на процессе купли-продаже?

нет и теперь продолжим создавать методы магазина.


операция покупки-продажи реализована, также история реализована.


далее мне нужно всё проверить.

Но экипировка должна быть универсальной? т.е проверять оружие, хил, броню и умную электронику одинакова?

Для умной электроникой будет иная проверка.

Дробовик - shotgun-damage300_strong2
Легкий полицейский бронижелет - Lightweight Police Body Armor
LPBArmor-Armor400_strong1
FirstAidKit_heal-HP100

скилы не являются тем что можно купить за ETO

А как тогда быть с умной электроникой?

По сути такая же строка характеристик.

название-характиристика1_характиристика2_характиристика3

далее всё просто..

Теперь ессть магазин доступен.

Далее нужно его организовать.

нужно дать выбор, купить или  продать.

если купить, то требуется ввести ID товара.

если продать, то аналогично ввести ID товар.

при покупки или продажи товара нет проверки на наличие товара.

предлагаю дообавить единый метод проверки.

не, не пойдет, это 2 разных словаря.

Меню проверил, пункты и операции работают исправно.

Нужно теперь добавить механику экипировки.

Экипировка, это лишь повышение характеристик.

Сразу уточню, хил работает из инвенторя, не нужно это экипировывать.

Экипировка зависит от механизма обработки строк характеристик.

назову его ID parser - id_parser

он будет принимать инструменты и персонажей.

Но я ещё не определился с персонажами.

У меня пока что есть лишь инструменты.

у меня не реализован механика экипировывания.

экипировывание, это простое перемещение обьекта из инвентаря в слоты.

именно перемещение, т.е продать экипированный элемент нельзя!

значит должен быть метод для того чтобы снять экипировку.

Я реализовал часть методов экипировать и снять экипировку.

Нужно сделать метод, который будет повышать характеристики исходя из экипированных редметов?

Нужно 2-3 метода работы с характеристиками?

Предположим, у меня есть умная электроника.

так, сек..

по порядку.

есть характеристики нашего персонажа.

Нужен метод для работы с ним, но для этого нужен метод который все характеристики преобразует в понятный набор данных.

Шаблон строки есть.

название-характеристика1_...

рекомендую изменить на:

название_характеристика1_...

тогда будет проще на строки разбивать.

Как тогда стоит это всё организовать?

Что влияет на характеристики?

декодер для строки характеристик сделал.

далее нужно теперь делать задания.

всего заданий бывает 3 вида:
ежедневные
одиночные
привычки

класс задание:
краткое описание
сложность
противник
сюжет
Приоритет
Создание
Сроки
Условия выполнения
Дополнительные задания


Класс получился очень большим..

думаю стоит сделать как в Habitica

класс Задание Ежедневное:
Заголовок
Заметки
Список
Дата начала
Повторение Ежедневно, через день и т.п - имеется ввиду сколько раз эта задача будет всплывать снова и когда
Сложность

класс Задание:
Заголовок
Заметки
Выполнить до
Сложность

Привычка:
Заголовок
Заметки
Полезная\Вредная
Сбросить счетчик -> раз в еделю, ежедневно, раз в месяц -> далее просто тапаешь + или - - выполнил привычку не вполнил, после сброса получаешь награду.


к этим классам легче адаптировать игру, но в моей игре большое разнообразие.

можно изменить ещё раз логику боя.

предположим, что сначала я выполняю задания просто так, по сюжету веду рутинную деятельность.

Но могу взять себе противника, и уже тогда каждое выполненное задание это урон врагу.

Предположим, мне нужно нужно уничтожить штурмовика или, целый отряд.

Как мне реализовать механику боя с отрядом штурмовиков?

В целом, достаточно просто создать врага - отряд штурмовиков, суммировать их ХП и урон - готово!

Я забыл сдобавить харктеристику в класс профиля - урон..

как я буду наносить врагу урон не имея такой характеристики..

тогда работа с умной элктроникой будет реализована иначе и зависить лишь от интеллекта.

наградой за выполнение задания может стать доступ к серверу, который при помощи инструментов потребуется взломать.

Также у каждого врага есть сюжет - причина по которой его требуется ликвидировать.

выполнение заданий без врагов, это простой фарм - типа на хлеб заработать, иначе урон будет получен от голода.

как мне реализовать повышение характеристик?

Может просто реализовать метод, который активируется при экипировки.

В этом методе и будет использован метод декодирования.

окей, тогда вот как будет выглядить логика этого метода:

def apply_to_characteristics(chars_line):

я думаю стоит реализовать проверку, типа damage к damage прибавлять, не смотря на последовательность указанную в строке характеристик.

когда с помощью метода экипировки я изменю характеристики, то как мне вернуться к первоначальным?

будет метод дефолт - который сбрасывает характеристики до дефолтных.

но вообще, стоит реализоваь не как замещение первородных на овые характеристики, а как прибавка одних к тем что уже были.

могут ли быть характеристики отрицательными?

по логики - да, могут.

механика экипировки добавлена.

теперь нужно добавить механику задний и битв с босами.

по сути сейчас я могу повыхать себе характеристики за счет того что экипирую тот или иной интсрумент.

как мне реализовать задания?

там же куча всего..

у меня уже есть опыт создания заметок через терминал, это не удобно, что пзд.

предлагаю оставлять лишь ID задания, а само задание хранить в obsidian.

есть ли для программы разница какой именно класс задния был добавлен?

что такое задание для программы?

1. Выдать награду - повысить уровень и т.п.
2. Нанести урон врагу.
3. Разблокировать что-то в умной электроники.

но есть же кликер привычек?

есть повторение заданий.

повторять следует лишь ежедневные задания.

у привычек сбор счетчика нужно устанавливать.

Я это всё писал сейчас, что убедиться в том, что мне нужно, что программа исполняла все эти механики сама, а я только галочки иногда стаил и награду получал.

можно сделать так:
1. Ежедневные задания.
2. Задание.
3. Привычка.
4. Назад.

Программа должна знать лишь:
Есть ли враг или дамаг мне без надобности.
Нужно ли задачу снова повесить в список и если да то когда.
Если у задания счетчик и если да, то когда сбросить его?

сбос счетчика, это пу сути отложенная выдыча награды.

но вот прикол, задание привычка после сброса счетчика не пропадает, а лишь начисляет награду и обнуляет серию очков.

следовательно имеет сммысл создать отдельные методы для каждого класса привычки.

класс Задание Ежедневное:
Заголовок
Заметки
Сложность
Список
Дата начала - от этого момента отсчитываются сутки? нет
Повторение Ежедневно, через день и т.п - имеется ввиду сколько раз эта задача будет всплывать снова и когда
Серия

класс Задание:
Заголовок
Заметки
Сложность
Выполнить до

Привычка:
Заголовок
Заметки
Сложность
Полезная\Вредная
Сбросить счетчик -> раз в еделю, ежедневно, раз в месяц -> далее просто тапаешь + или - - выполнил привычку не вполнил, после сброса получаешь награду.

в Habitica очень сложно реализованы задания, но более эффективно в отличии от моего 1го общего класса задния.

В Ежедневных заданиях есть серия.

Я так понял, от серии очков как и от счетчика, повышается ценность задания.

От выполнения задания повышается шанс нанести критический урон.

Серия очков - +1 после выполнения задания, +2 - если я сразу же выполню задание на следующий день.

Это можно также проверять с помощью программы.

1 серия равна 1% от ценности задания. Чем выше серия, тем выще итоговая награда.

также после выполнения задания накаплививается шанс получить трофей 1 задание == 1%.

также в habbitica от силы игрока увеличивается и сила критического урона.

Получается мне нужно добавить характеристику - крит урон?

по сути, тогда оружие увеличивает крит урон?

Это слишком сложно, предлагаю упростить.

пускай от силы зависит крит урон.


есть даже формула, по которой это всё расчитывается.

мне не стоит сейчас относиться к этой задачи с задачами как менеджкру задний.

нужно понимать что сейчас я разрабатываю систему боя.

зависимость от силы повышается крит урон.

крит урон - это бонус в процентах.

немного запутался.

есть шанс получить крит урон - нанести т.е.

это зависит от силы игрока.

В этом случае предлагаю сделать более логичное решение в моём случае.

сделать увеличение крит урона за счет инструментов.

добавил.

трофеем можно считать какой-то предмет который выпадает с персонажей.

за провал обычных заданий в habitica падает HP, у меня HP может падать лишь от чего-то.

например, от голода или врагов.

но от голода звучит механика не плохо.

НО, есть физический мир для того чтобы голод отслеживать.

я думаю может сделать задания без врагов, но которые допустим просто лутание?

нет смысла, если я от лутания получаю урон.

если я в заднии лутание провалю задание, то получу урон от рандомного события, может так?

нет, тоже фигня.

также мне нужно добавить в меню список персонажей общих.

это типа враги и не доступные мне сейчас персонажи.

боюсь чтобы я не придумал, в любом случае мне нужно упростить.

мне нужно создать один оборот цикла боя:

- Задание выполненно
-- Высчитываем шан выпадения смены урона на более высокий.
-- итоговый Урон врагу.

- Задание провалено
-- Узнаем урон наносимый врагом.
-- Наносим урон игроку.


В общем нужно создать базовый класс Задание и от него просто наследовать всё остальное.

а обьекты заданий хранить как экземпляры класса.

проще некуда.


Основа всех классов готова.

Далее нужно реализовать индивидумальные методы для работы с данными.

Начну с одиночного задания.

Оно простое самое, нужно лишь отслеживать время.

Например, выполнить до 13.07.2024 23:00

Мне не хватает планировщика и методов завершения задач - они должны быть реализованы в родительском классе.

В планировщике будут храниться запланированные задачи.

В том числе и серии.

Но планировщик должен быть универсальным и простым.

Кто будет работать с планировщико и что там будет.

Только задачи.

мне нужно чтобы там весели задания, типа:

(текущие время - время запланированное)
если текущие время равно или больше запланированного, то выполнить действие 1.
иначе выполнить действие 2.


Ошибоччка вышла.

Описание и заголовок будут лишь в Obsidian.

Нужен класс GTaskSheduler.

В нем определить лишь работу со временем.

он никоем образом влить на характеристики или на врагов или ещё на что кроме задач не будет.

Покрайней мере напрямую.

Предположим такой класс есть, что дальше?

дальше нужны методы которые выдают награду и которые наносят урон.

метод для выдачи наград, выдает и трофеи.

а как ксатити мне использовать хилки?

может для этого создать отдельный метод?

нет, не думаю, нужно создать метод ограничивающий исцеление, также нужен метод ограничивающий ремонт защиты.

я думаю это будут не методы, а функционал метода который отвечает за работу с характеритиками.

нужно задать простое правло: если предмет для ремонта или исцеления привышает уже установленный лимит HP и armor, то отклонить такой предмет при экипировки.

тогда нужно 2е простое правило, не может быть 2 armor инструмента.

всё же правил будет несколько..

ещё нужно сделать так, чтобы через меню экипировки нельзя было экипировать предметы которые увеличивают HP, можно только те, которые его восполняю, но не привышают первоначальное значеие.

а для увелечения обьёма HP, нужно предумать отдельный мето и механику.

но все эти правила добавлять в метод apply_to_characteristics() в качестве проверки нет смысла, ведь это метод общего действия, ему всё равно что я делаю с характеристиками.

мне нужны отдельные методы в методах меню экипировки.

--------

мне бы в идеале сделать бы уже методы для нанесения урона..

мне нужно сначала реализовать класс врага.

class NPC:
	HP = 100
	armor = 1000
	damage = 500
	
Это примитив класса с характеристиками штурмовика.

Думаю стоить сделать класс родитель и от него наследовать всех остальных.

Ля, но аналогичным образом следовало бы поступить с играбельными персонажми..

Так, окей, а чем играбельный отличается от не играбильного персонажа?

Тем, что у не играбильного нет такого огромного профиля.

В watch dogs legion, нет особой разнице в прохождении за Эйдена Пирса или иного персонажа.

Конечно есть некоторые особые навыки присущие тому или иному персонажу, которых нет или частично есть у иного.

По большей степени разница там лишь в том, кем я себя ощущаю во время игры - крутой легендой чикаго или дерзким умным бунтарем Рэнчем.

Ну а так, я запросто могу взять себе любого NPC и играть им.

класс универсален.

но как это почувтсвовать играя через терминал?

Ну, будет в профеле что-то типа:
*Эйден Пирс
Шерлок Холмс
Ренч
...

где многоточие - это намек на то, что есть ещё персонажи, кроме перечисленных.



Я вот думаю, может к характерстикам NPC добавить трофей и крит урон?

Чтобы была какая-то вероятность что и мне враг нанесет крит урон.

Станет ли это накладным? Вряд ли.

NPC класс полностью реализован, что дальше?

Сам по себе файт, это алгоритм.

Далее мне нужно реализовать планировщик офлайе.

Задания - 
Ежедневные - репит, 

У меня даже и близко нет представления о том как будет проходить бой

У нас при выполнении и провале задания, есть только 2 вариант, игрок либо наносит урон врагу либо врага нет и урон наносить некому.

за бой может отвечать метод fight, в нем можно реализовать всю логику.

В планировщик можно отправлять класс задания и имя метода, который должен быть выполнен.

Получается, мне нужен метод который создает задание.

Т.е при выборе в меню класса задания, будет список текущих заданий и возможность добавить выбранный класс задания.

Добавлять NPC и снаряжать их можно будет через меню разработчика.

У каждой задачи должна быть дата завершения?

Нет, некоторые задачи не могут весеть в планировщики до тех пор пока не будут просто выполнены или не выполненны.

По логике игрок не должен влиять на метод который будет исполнен во время провала или победы.

Покрайней мере напрямую.

Допустим я хочу создать ежедневное задание.

Дата начал по умолчанию - сегодня.
Повторение по умолчанию - ежедневно
Кажд. по умолчанию каждый день(можно и через день, типа Кажд. 2 дня.


Теперь я хочу создать одиночное задание.

Выполнить до - нет


Теперь я хочу создать задание привычки.

Сброс счетчика по умолчанию Ежедневно.



Всё.


они все разные, лол.

по сути мне и планировщик не нужен.

Мне нужен метод который просто будет проверять время завершения задания с текущим.


как реализовать повтор задания?

Можно создать простой метод, который покажет нужно ли задачу повтарять или нет.

также есть проблема, я не могу проверить та ли сегодня дата или нет..

решил проблему.


check complition time

check repeat time

репит каждые 4 дня

дата начала 10.07.2024
следующая дата повтора - 10+4.07.2024

текущая дата 11.07.2024

ещё рано.

Значит нужен метод, который отвечает на вопрос, пора снять задачу или нет.

у задания привычки нет такого метода!

проблема метода прибавки дней к дате в том, что месяц не меняется, а также год не меняется, а также может быть более 31 дня, а в некоторых месяцах 30, в других 31, а в одном либо 29, либо 28..

проблема решена.

что дальше?

далее нужно понять, пора ли делать рипит или нет.

Т.е, теперь есть срок, в который нужно сделать репит.

Я реализовал методы которые отвечают на вопросы выше.

Вероятно планировщик мне всё равно нужен.

Должен быть метод который проверяет стоит ли завершить ежедневное задание - т.е если дата уже изменилась.

теперь нужен метод для работы с задачами.

Для этого нужно просто сделать метод который спрашивает нужно ли отобразить задачу или нет.

Само меню задач.

Я думаю, нужно ли добавить листание задач? Да

Кнопка далее должна быть только если задач более 3? Да

Редактирование? Да, оно будет в меню для разработчиков.


Ежедневные:
ID_1: ++++
[INFO]: 12.07.2024: 4

ID_2: ++
[INFO]: 12.07.2024: 4

ID_3: +++
[INFO]: 12.07.2024: 4

-----
1. Добавить
2. Завершить
3. Удалить
4. Далее <- Появляется лишь если есть куда листать, если нажать далее, то если 
	    это конец, кнопка меняется на назад.
	    
New Ежедневное:
ID> ID_4
------
[Повтор каждые]: 4 <- В днях
-----
Сложность> +++ <- Максимум ++++



Одиночные:
ID_6: ++
[До]: 14.07.2024

ID_7: ++
[До]: 14.07.2024

ID_8: ++
[До]: 14.07.2024

-----
1. Добавить
2. Завершить
3. Удалить
4. Далее <- Аналогично

New Одиночные:
ID> ID_9
-----
[Выпол. до]> 14.07.2024
-----
[Сложность]> +++



Привычки:
ID_11: ++
[Сброс]: 30 дней

ID_12: ++
[Сброс]: 30 дней

ID_13: ++
[Сброс]: 7 дней

-----
1. Добавить
2. +
3. -
4. Удалить
5. Далее

new Привычка:
ID> ID_14
-----
[Сброс каждые]> 1 или 7 или 30
-----
[Сложность]> +







-----------------------------------------------------------------------------------------

методы для сравнения дат не работают..

Так, методы работают, я их оформил не правильно.
player profile
Я настроил методы занова, должны работать.

метод будет в меню заданий.

Для начала нужно написать метод который отображает все задачи.

В идеале нужно просто перенести все методы и классы в соответсвии с их модулями.

Что сделать затруднительно, поскольку они все друг с другом связаны, а работу многих нувых методов я ещё не проверил.

Все кроме новых методов работают.

нужно лишь понять на какие модули и что нужно поделить.

По сути, некоторые модули должны загружаться первыми, другие последними.

Ладно, разабьём на модули позже.

Я уже в коде путаюсь, а это ещё далеко не финальная вариация структуры кода..

Нужно разбить на модули!

Есть модуль - store

Далее идет - player_profile

У меня есть ещё методы купли продажи, это же можно отнести к модулю store?

По логике да.

Но эти методы я пожалуй оставлю там, где они есть.

Следующий модуль - task.

Но есть проблема, меню магазина находиться выше метода, который как раз за задачи и отвечает..

Я думаю в этом случае поднять классы и методы

Следующий идет класс person

В целом, по модулям раскидал.

Далее нужно создать меетод для работы с задачами.

Методы отображения заданий лучшего всего реализивать в самих классах.

Все ежедневные задания будут храниться в текстовом файле?

Но, ведь каждая задача, это экземпляр класса задания.

Из чего следует, что я просто сделаю в каждом классе задания метод сериализации.

Т.е когда программа запускается, все задачи снова будут в виде экземляра класса задания.

Ну если так то ок, но а как же таймеры на задании?

Программа не знает когда именно нужно проверить таймеры в заданиях.

Нужно реализовать проверку, проверка будет каждый оборот цикла основного меню.

конечно я бы мог упростить себе задачу, убрав автоматическую проверку таймера на задании, а самому вручную указывать завершина задача или нет.

Но это слишком топорно и мне мне всегда захочется вручную этим всем заниматься, автоматизация лучшее решение.

Но ведь задачи храняться в массиве задач, разве нет?

Да, стоит сделать один общий массив.

Но посколько будет поиск по ID стоит сделать словарь - [ID : task_obj, ...]

Реализоывать все сохранения лучше всего в отдельную папку - DataApp.

Но самой реализацией займусь когда допишу первую версию приложения.

Хоть задача и имеет свой принт, но принт меню должен реализован отдельно.

Я поспешил с реализацией отдельно принта.

Нужно реализовать упрощенное заполнение для каждого класса задачь.

Потому что у всех задачь есть заголовок и описание.

Но форат заголовка и описания у всех свой.

Из этого следует, что нужен индивидуальный метод для упрощенного заполнения.

В целом метод можно сделать единым и менять лишь текст в полях.

Можно проверить модуль task.

Нужно создать меню для работы с классами задач.

У меня теперь универсальный метод для заполнения заголовков и описания.

Есть метод который проверяет пора ли уже выставлять задачу в список задач или нет.

что дальше?

Дальше это всё нужно связать воедино.

Меню у каждой задачи свое.

Нужен не общий метод меню задачь, а для каждого класса, своё меню.

я написал первый метод для одиночных задачь, как мне сделать ограничение в отображении?

Мне нужно отобразить лишь 3 шт, если уже больше 3х, то отложить отображение на след страницу.

По сути всё просто, нужно просто выгрузить сразу все задания и потом отображать их индексом.

Сначала от 0 до 2, пото от 3 до 5 и т.д.

Нужен общий метод который разбивает массив на страницы.


У меня делема, в меню привычек, есть + и -, там при нажатии + или - прибавляется или убавляется серия.

Придумал!

Нужно сделать 2м пунктом выбор задания к которому прибавить серию.


В меню привычки есть 2 не учтенные детали: 1 - нет надписи "дней" 2 - нет возможности посмотреть текущию серию.

исправлю 2е, а первое пофиг.

Я дописал меню заданий и даже проверил что как работает, в целом всё отлично, остальное по ходу исправлю.

Также я добавил возможность просмотра серии.

Теперь нужно реализовать механику боя.

Почти все пункты меню были реализованы, осталось только систему боя реализовать.

Получается, что еслии я выполню задание, то нанесу урон врагу, если враг был привязан к заданию.

Но вот нюанс, у меня нет возможности привязать к заданию врага.

Также меню персонажей ещё не было реализовано.

Из чего следует, что ключивые механики ещё не реализованы, а именно нужно доработать меню персоонажей, сразу как определюсь с тем как к заданиям мне привязывать персонажей NPC.

С одной стороны задача очень простая, достаточно лишь создать отдельный словарь, по типу: {ID : NPC, ...}

Но если я реализую такой массив, его придётся проверять переодически..

То что касается проверки, я забыл реализовать проверку текущих заданий...

ля.. мне же нужно реализовать меню активных заданий..

с одной стороны, их можно отобразить в профеле, с другой это не очень хорошая идея.

Но может не стоит замарачиваться над вторым заданием?

Да, ведь можно просто добавить проверку времени.

По сути любое задание которое есть - активное, тогда нюанс в том, что задание активно лишь в определенный период.

Как раз таки проверку на - не закончился ли период активности задания мне и требуется.

Как это сделать?

Метод проверки будет содержать всего-лишь 3 запроса к классу задания.

Но, у меня есть массивы для каждого отдельного класса.

соответсвенно, мне нужно перебрать каждый словарь и вызвать метод проверки срока годности.

если у задания уже просрочен срок, его просто нужно удалить?

тут в силу вступает механика боя и противник привязанный к заданию, наносит мне урон.

Но, ведь в habitica, бой идет исключительно с боссами, т.е выбирается босс и все задания привязываются к нему.

из этого следует, что враг должен быть лишь один.

Т.е, мне нужно реализовать сначала механику боя.

Как мне выбирать врага? И главное зачем, в чем плюс выбора врага?

Выбор врага, как реализовать эту механику?

в habitica выбор врага - это покупка свитка за изумруды, доп валюту.

но и насколько помню свиток босса доступен в магазиине лишь с определенного уровня.

ля, у меня ещё не реализованна система вознаграждений от серии очков..

как будет устроена эта механика?

ни в одном классе задании не указана награда.

Вообще в любом классе, а точнее в родительком, должен быть пункт с наградой.

Награду задавать требуется во время заполнения класса.

но по сути, награда относиться к описанию, что как было ранее обговорено, находиться в obsidian..

Но ведь в obsidian храняться лишь карточки персонажей, а также карточки инструментов..

Для простоты, стоит перенести основную нагрузку в программу, а всю вспомогательную в obsidian.

Таким образом, награда должна быть в программе, ведь она сумируетсяя в профиле игрока автоматически, из чего следует, что награду также требуется указывать в программе.

Добавил в родительский класс награду.

Любая наград и в любом классе должна выдаваться лишь по финальному завершению..

в habitica награда выдаётся отдельно от задания..

Т.е в описании задания можно написать кол-во наград и после просто вознаградить себя..

С одной стороны удобно, с другой не обычно.

А.. я понял. В habitica, награда выдаётся автоматически, в зависимости от уровня игрока..

А в пункте наград, можно купить себе доп награду, например за 100 золота купить себе отдых или снаряжение, например сундук с радомным снаряжением.

это весьма удобно.

вероятно мне стоит сделать аналогичную систему вознаграждений.

т.е система сама будет выдавать награду в зависимости от моего уровня сложности и от моего уровня игрока.

ну, за полезные привычки я получаю лишь 0.6 монеты, за ежедневное и одиночное 1.

При этом, мой уровень растет, а награда нет..

Кстати, систему рангов и уровней, можно взять из моего прошлого проекта.

Единственный нюанс, система рангов плохо адаптирована, там не удобный интерфейс.

Можно взять тогда часть кода.

рейтинг это круто, но для начала нужно награду определить.

в habitica с валютой не замарачивались, 1 монета, это просто 1 монета.

вероятно мне тоже стоит последовать их примеру.

почему бы за 1 ETO не продавать товар?

Всё ведь зависит от ценности валюты, чем валюта дешевле, чем больше её единица.

предлагаю сделать автомаическую систему наград с возможностью корректировки через меню разработчика.

награда за 1 задание будет 1 ETO - +
2 ETO - ++
и т.д

где должены быть настройки наград?

Я думаю их стоит внести в класс профиля игрока.

готово, сделал в лучшем виде.

теперь нужно доделать меню с персонажами.

как оно будет выглядить?

по сути, есть лишь персонажи враги и персонажи союзники.

ну, если быть точным, то персонажи играбельные.

Конечно не могу не отметить, что смысла в это не много и всё же.

тут тоже стоит упростить.

у меня есть функционал ввлияющий на крит урон и остальные характеристики.

можно реализовать персонажей играбельных как набор характеристик, ведь у меня есть метод который полностью меняет характеристики.

когда будет экипирован набор характеритик персонажа, я смогу как бы играть им.

нужно добавить это в правила.

добавил.

Системы уровней у меня нет, есть система рейтинга.

Её я добавляять не стану, она сильно всё усложнит и я даже не знаю что мне это даст.

в habitica система уровней нужна лишь для того чтобы можно было постепенно познавать всякие плюшки приложения.

У меня познавать та что? Я же сам приложение создал )

Для меня главное это всякие прикалюхи получать и прочувствовать атмосферу прошаринности и прч.

Как-то так выглядять мои эмоции от моей идеи с игрой в буквах.

------------

Теперь, когда я уже определился с тем для чего мне играбельные персонажи и как мне быть с врагами, продолжим.

Как мне выбирать врагов?

В habitica дают свитки врагов за монеты в магазине квестов, но там враги, это боссы.

У меня же нет такого определения как боссы враги.

также, есть момент который я не продумал до конца.

у меня есть интрументы, которые имеют свойства перезарядки.

Я думал сделать так, когда в инструменте кончаются заряды, обнулять урон от него.

Но в программе не реализована такая фишка.

Точнее в строке характеристик инструмента нет правил использования инструмента или свойства заряда.

я могу сделать так чтобы это свойство было учтено следующим образом.

Для начала добавим характеристику в профиль игрока - charge - заряд.

Хотя, заряд можно явно в профиле не прописывать, это же никакого отношения к игроку не имеет.

Это свойствва инструмента, которое может быть, а может и не быть.

Допустим броня. Она иеет свойства заканчиваться..

Ля, а если броню снесут, а я попытаюсь её снять.. у меня же минус получиться?

По сути да )

Из этого следует, что нужно добавит след правила.

Если, показатель характиристики броня отрицатеельный, его стоит сделать просто 0.

У какого показателя может быть отрицательное значение по мимо  брони?

У урона и hp.

Урон, это кончились заряды.
Броня, был нанесен урон по броне.

Оба сценария приводя к отрицательному значению, если после этого снять инструмент.

Ну, в общем я исправил недочет, теперь в случае отрицательного значения программа автоматом изменит на ноль, прежде чем внести изменения в профиль.

Есть ещё кое что, это смерть игрока.

У меня нет метода который бы в случае нулевого HP производил операцию штрафа игрока.

И плюсом у меня была идея сделать классный принт смерти в случае нулевого HP.


арт я нашел.


далее нужно реализовать свойство заряда.

Оно по сути может считаться универсаьным.

Выбор противника, как он будет выглядеть?

И будет ли уровень сложности задания на что-то влиять.

В habitica сложность влияет на урон от босса и награду.

У меня сложность влияет лишь на награду, чего достаточно, следовательно я не стану больше ничего к этому прибавлять.

Но ведь враг не зависит от сложности задания.

Если так, то как я могу использовать уровни сложности заданий на выбор врага.

Можно сделать так чтобы уровень сложности задания зависил от того какого врага я беру.

Но прграмма лишь калькулятор, а не полноценная игра.

Тогда как будет происходить выбор персонажей?

Мне хочеться поставить игровое препятствие при выборе персонажа.

Например поставить цену при выборе или сделать ещё что-то..

Хотя это всё можно сделать не в программе, ведь по сути, с врагом всё просто.

Выбор врага можно сделать в каталоге obsidian, а уже добавить его в прогамму можно аналогично добавлению инструмента.

Т.е не будет меню для выбора персонажа, а будет просто поле для установки противника.

Класс врага готов, что дальше?

Нужно 2 метода - 1. Проверка срока годности заданий. 2. метод боя.

Для начала следует метод боя реализовать.

Он напрямую связан с экземпяром класса NPC.

Нужно явно сделать ограничение на создание экземпляров класса.

Сделал.

Метода будет 2. Первый в классе NPC, второй в классе задания.

Оба метода вызываются в разных случаев.

С этим ясно, а как быть со свойством заряда?

легко, изначально заряд 100%, если у инструмента в строке характеристик указан расход заряда, то метод боя будет уменьшать эти 100% после каждого вызова.

но я уже запутался.. слишком сложно.

нужно начать с простого.

Метод проверка срока годности задания не должен напрямую воздействовать на харктеристики, он просто вызывает меоды, либо из профеля игрока, либо из профеля нпс.

Ладно, я снова путаюсь.

Просто реализую проверку.

также у меня нет оповещания при нанесении урона мне, т.е когда задание не выполненно или просрочено.

что произойдет если провалю или просрочу задание? Одно и тоже - я получу урон, равный указанному в характеристике враг, а также сработает метод лотереи - крит урон, кто его получит.

а что будет когда я выполню задание? - я буду учавствовать в лотереи - крит урона, а также враг  получит урон в соответсвии с тем что указан в профиле игрока.

это всё?

нет, урон наноситься по броне до тех пор пока показатель не стане равен 0 или меньше 0 - работает в обе стороны.

в случае когда я обнулю HP врага, я с определенной вероятностью получу трофей с врага, указанный в строке его характеристик.

мне нужно добавить метод для добавления врага.

---------

А что будет происходить при сбросе серии?

По сути, сейчас просто сброиться серия и всё.

В Habitica чем выше серия, тем меньше награда, соответственно сброс серии, снова восстановит задание.

Значит мне нужно реализовать уменьение награды, но у меня награда только целочисленная и то, награда и так не велика.

Но я думаю наоборот, по набору серии кратной 20 ил 30 надбавить награду.

Конечно стоит лучше сделать так, если я набрал 30 очков, то награда х2.

Ну или пофиг, пускай просто обнулиться серия )

Ля, как же сложно, у меня нет элемента, который бы уберал ежедневные задания ..

мне нужно сделать для каждого задания статус.

активныое, не активное.

Не активные задания не отображать, а активные отображать.

ля, я в конец запутался, мне очень тяжело проверять задания на дату..




Всё просто, если задание ежедневное, то проверить не кончился ли день и если кончелся, сделать задание не активным.
И да, если день кончился, а задание активно, значит игрок его не завершил, за что получит урон.

После чего нужно проверить, пришло ли время повторить задание, если сегодня нужная дата, снова сделать задание активным.


Спасибо, далее я не понимаю как быть с одиночными заданиями?

тут ещё проще, там всё расписано в комментах кода.


А как быть с заданиями привычек?

Там проще некуда, если я нажал - то получаю урон, за не соблюдение привычки, если + то наношу урон.

В методе для проерки, просто нужно либо сбросить счетчик серии, либо не сросить

Ну и наконец готово.

Далее остается метод урона.

Урон от врага я реализовал.

Критический урон тоже учел.

Теперь нужен тот же метод, но для игрока.



Теперь я запутался в том как мне завершить задание?

нужно выдать награду в соответсвии со сложностью, далее нужно нанести урон врагу - атаковать его.

я в прошлом забыл при заполнении добавить уровень сложности в поле сложность, которая в добавок не имеет ни геттера, ни сеттера в родительском класса.

Я добавил также метод в профиль игрока, позволяющий получать награду в соответсвии с настройками наград.

Теперь также можно узнать сложность задания, получив прямой доступ к полю сложности в любом наследники класса Task.

Изменил прядок импорта, для того чтобы методы модуля Task имели доступ к методам модуля person в котором все методы NPC - противника.

Теперь есть метод атаки у противника - NPC и у игрока.

Но я забыл расчитать шанс выпадения трофея с NPC.

Шанс будет 40%.

Вроде бы всё, но я у меня нет ID врага чтобы протестировать.

class NPC:
	    self.HP = HP
	    self.armor = armor
	    self.damage = damage
	    self.strong = strong
	    self.critical_dmg = critical_dmg # % - максимум 45%
	    
	    self.drop_trophy = drop_trophy # Это отдельный tool_id предмета.
	    
	    
bot_HP=100_armor=200_damage=10_strong=3_critical-dmg=45_drop-trophy:gun_damage=100


Долго и мучительно, долго и мучительно, но я протестировал новые механики и исправил кучу старых багов..

Были ещё некоторые механики которые остались без внимания в связи с тестированием этой огромной механики.

Ну да ладно, главное это сейчас реализовать механику смерти, а именно анимацию и механику.

При смерти игрок теряет часть инвенторя, рандомные предметы, а также теряет все ETO.

Из анимации, появляется смерть с косой в виде принта.

как реализовать потерю 1го рандомного трофея?

bot_HP=100_armor=200_damage=100_strong=3_critical-dmg=45_drop-trophy:gun_damage=100


осталось сделать возможность сохранять данные в файл.

какие данные требуется сохранить?

Модуль - main - не требуется.

модуль - store - store = {} и store_ETO

модуль - functions - не требуется.

модуль player_profile - все поля класса.

модуль - person - все поля класса.

модуль - task - single_task_dict, habit_task_dict, daily_task_dict.


По мимо этого, ведь по сути при запуске приложения, а имеенно до начала цикла main, все данные приложения должны веруться в свои поля.

Т.е нужно произвести инициализацию до начала цикла.

в модуле магазина должна происходить инициализация из файла, но лишь один раз!

Но, а если будет неожиданное закрытие программы? А что если читать всегда из файла и писать туда же?

Не.. там весь код переписывать, плохой тон.

Тогда нужно реализовать сохранение в одном месте.

сразу после выхода.

Можно просто реализовать при нажатии на кнопку назад.

Я начал с магазина.

Я больше запутался в том как мне записать в файл словарь и отдльное значение


может реализовать чтение и запись данных непосредственно из файла?

Ну, в профиле например, все методы обращаются к классу, а не к файлу.

Из чего следует что нужно сохранять данные после закрытия программы.

Но закрытие программы, это либо я просто закрыл среду где она запущена, либо нажал кнопку выход.

Могу ли я отследить момент закрытия среды?

Нет, если я сверну на смартфоне приложение консоли, то программа ничего не сможет сохранить, даже если будут обработчики сигналов или try finally блок.

Я могу лишь отслеживать нажатие кнопки выход.

Либо я могу сделать одну кнопку - сохранить.

Либо, я могу спрашивать игрока перед выходом, сохранить ли мне состояние программы или нет!

Так и сделаем )

Ля.. а как быть с восстановлением данных?

Очень просто, нужжно не просто сохранять данные, а также нужно записывать, были ли данные сохранены ранее.

но при таком раскладе, я могу и сохранять автоматически..

нужно лишь сделать следующие, если данные были ранее сохранены, то данные восстановить, иначе данные не восстанавливать.

это можно при срабатывании общего сохранения обозначить - записав в какой-то файл 1, или если данные игры не сохранялись, то 0.

Вопрос, а для всех файлов нужно делать восстановление или это приведет к затеранию данных?

вообще, стоит произвести инициализацию всех переменных из файла.

а сохранять или нет нужно лишь тогда, когда изменения были внесены.

так, стоп..

если все переменные инициализируются из файла и у них не бывает состояния 0 или None или пустого массива или словаря явно обьявленного, то..

как файл будет изменяться при внесение в эти переменные изменения?

тут наблюдается противоречие, если все переменные инициализируются только из файла, то зачем мне пременные?

тут нет противоречия, переменные необхдимы чтобы их можно было изменять не внося изменения в файл постоянно.

по сути, инициалихация переменных из файла подразумевает что в файле все исходные состояния переменных храняться.

если это так, то данные не будут затираться при перезапуски приложения.

также в этом случае, сохранение состояния программы, это внесение новых исходных состояний переменных в файл.

это можно сделать след образом: при сохранении, запрашивается текущие состояние перееменных и оно же в файл записывается.

Да, это устранило в моей голове путаницу и решило проблему.

магазин работает исправно, осталось добавить в меню разработчиков способ удалить предммет из магазина.

готово.

приступаю к player_profile

для этого модуля релализовал сохранение.

нужно реализовать метод который вернет значения в форму по умолчанию.

функционал добавлен.

я забыл поставить ограничения на силу и интелект!

ограничители установлены в их сеттеры.

person готов.

приступаю к task.

все словари содержат эземпляры классов, следовательно нужно реализовать для каждого словаря метод, который будет использоваться json для сериализации каждого обьекта.

по идеи аналогично они же и будут восстановлены.

не смотря на кажуюеся сложность, тут всё достаточно просто, нужно лишь в каждом классе задачи реализовать его собственный метод  dump и load.

оказывается в моих классах не обычная дата сериализуется, а класс datatime, лол.

это не входило в планы и я хз как это разрешить.

Вот я тупень, геттеры и сеттеры для NPC не реализовал, теперь каждый раз буду отдельно для кадого доступа к переменным устанавливать проверку на отрицательные числа.

Хотя.. можно сделать так:

когда противник нейтрализован, нужно просто сбрасывать к настрйокам класса по умолчанию.



bot_HP=100_armor=200_damage=100_strong=3_critical-dmg=45_drop-trophy:gun_damage=100


Странно что каждый раз когда я побеждаю врага, мне падает трофей, шанс выпадения которого меньше 50%..

я снова сделал ошибку, я считал что если рандомное число от 0 до 100, выпало боле 40, значит я получаю трофей, а нужно, что мне выпало 40 или меньше, тогда я выйграю трофей.

Это исправил.

Теперь я заметил, что при сохранении настроек NPC, наноситься прошлый урон по дефолтному классу NPC, чего быть не должно..

Я исправил один баг, связанный с тем, что если я попытаюсь добавить противника, но ничего не ввиду, то противнек не будет добавлен.

А то из-за бага я мог получать трофеи пустые..

Я могу добавить сохранение противника, только если у него значения отличаются от дефолтных, но это слишком топорно и приведет в багам.

Из чего следует, что я этого делать не буду.

Тогда нужно выяснить, по какой причине проивник сохраняется с отрицательным значением HP, если изначально был положительный..

Такой эффект наблюдается, если я просто уничтожаю врага и потом в главном цикле делаю несколько холостых оборотов.


ЛЯ... чо это за х2йня?? ["bot", "100", 200, 100, 3, 45, "gun_damage=100", true]

Откуда три сранных значения после bot???

Ладно, тут проблемы не было можно сказать, строку на инт и всё ок.

Отрицательное значение никак не отражается на то как будет добавлен новый противник, потому что старые значения, даже отрицательные, просто перезапишутся новыми.

Проблема решена, осталось только механику с зарядами добавить.

Может ещё протестить.

Нужно добавить механику зарядов для инструментов.

По сути это выглядет так:

Добавим новое поле, Charge.

Также нужно определить на что влияе заряд при обнулении.

Можно сделать так, добавим к полю заряд то на что он влияет:
charge=damage или например charge=armor


Но для этого придёться делать новый декодер? Нет

декодер просто сделает ключом charge, а всё что после = будет значением.

Добавить поле также будет не просто..


Заряд == 100, это должно быть 100%.

Так, тогда пусть знчением заряда будет массив:
charge=[100, armor]

В профиль я не стану добавлять в заряд, он должен добавляться лишь в инструмент, что также сильно упрощает задачу.

Все инстрменты влияют на характеритики профиля, также можно было и добавить заряд в профиль.

Но можно заряд добавить в один метод, player_attak(), а везде кроме этого метода игнорировать данное поле.

У каждого инструмента либо есть заряд, либо нет.

Из чего следует, что нужно добавить проверку на существование данного поля у инструмента.

Кое-где я всё же просчитался, как оказалось в методе атаки не используется инструменты, а используется характеристики.

Но, я ведь могу сделать умнее, я извлеку каждый инструмент из массива экипировки и проверю заряд там, если заряд равен 0, то обнолю характеристику инструмента к которому он привязан..

После обнавления харктеристики, я снова его помещу в массив экипировки.

Нужно использовать метод экипировки предмета.

Ля... Кривой код оказался, чтобы экипировать предмет снова можно лишь через меню...

Характеристики менять предёться вручную..

Может это и к лучшему, ведь теперь я просто именно в бою буду обнулять заряд, а не у персонажа.


РЕШЕНИЕ:
Тогда я просто вычту характеристику инструмента от характеристики в профеле если заряд равен 0.

Далее просто восстановлю характеристику, когда заряд будет восстановлен.

-----

Мне нужен метод для восстановления заряда.

Как это сделать?

Заряд обязательно нужно добавить как характеристику персонажа, на ровне с выносливостью.

Нет, это не выносливость и добавлять не лучшая идея!!!

Потому что заряд есть у конкретного инструмента.

Заряд должен автоматически восстанавливаться если есть предмет восстановления в инвентаре, а не в экипировки.

1. Проверка инструментов на наличие поля заряд
2. Проверка заряда, если 0 то
2.1. Проверить есть ли в инвнентаре предмет который восстанавливает для этого инструмента заряд, если да то
2.2. восстановить заряд
2.3. Иначе
3. вычитать привязанную к инструменту характеристику из характирисик игрока
4. Если заряд не 0, то
5. продолжить алгоритм атаки без изменений.



Пример инструмента который восстанавливает заряд для инструмента:
name_recharge=tool_id
['name', ['recharge', 'gun'], ['damage', '100']]

Метод проверки заряда автоматически поймет сколько восстанавливать.

Нужно добавить механику покупки нескольких интрументов одинаковых.

По мимо проблем с тем что у меня отсутствует механика дубликатов, у меня нет возможности сделать граммотно восстановление характеристик при перезарядки.

А именно, я не могу понять как реализовать проверку на - требуется восстановит или не требуется.

Я бы предложил так, если заряд инструмента упал до 0 и он находиться в экипировки, то снять его, что должно привести к вычету характиристик предмета от характеристик игрока.

Я решил вопрос с проверкой - просто снять предмет - от чего автоматически характиристики предмета отнимуться от характеристик игрока.

вопрос с дубликатами предлагаю решить так:

Так как, мне по сути не нужно 2 оружия в инвенторе, а лишь перезарядка, то я просто укажу в инструменте вместо характиристики которая снимается у предмета в случае нулевого заряда кол-во зарядов.

Потому что не важно какая должнахарактиристика сниматься, я просто сниму все характеристики инструмента.

Так не получиться, это нужно всё же добавить ещё одну механику, а я этого делать не хочу.

Есть прикол один.

Я могу снять предмет, а после боя снова его надеть )

По сути это поможет мне не добавлять постоянно предмет снова в экипировку.

И если сильно нужно, то заряд можно покупать по несколько штук, достаточно лишь имя изменить с пули на пули1 и пули2 и т.д.


bot_HP=100_armor=200_damage=100_strong=3_critical-dmg=45_drop-trophy:gun_damage=100


кажется я забыл реализовать механику разрядки инструментов..

по сути, каждый бой, если интсрумент имеет свойство разряжаться, будет разряжаться на 30%

как мне легко и быстро изменить у инструмента заряд?

по сути мне потребуется его сначала разобрать, а потом собрать снова...

исправил.

patron_recharge:gun_damage=500_charge=0

Появился странный баг.

При удалении старой версии инструмента и добавления новой, почему удалятся оружие!

Понял причину, я удаляю инструмент прямо из слота, а потом сразу пытаюсь добавить его в слот.

Вылазиет ошибка - предмета нет в инвентаре.

По сути нельзя через метод экипировки предмета надеть предме которого нет в инвентаре.

кол-во багов снова выросло.

на этот раз при повторной экипировки вырастает кол-во занятых слотов.

Это связано с тем, что я добавляю предмет из инвентаря, просто удали 1 от общей занятости слотов.

Также по  этой причине увеличиваются в двое характеристики.

на этот раз я уж не отделаюсь простым вычетом характеристик...

придетсья добавлять в экипировку предмет напрямую.

исправил.

остался вроде как последний баг.

у предмета пропадает свойтсво заряда при добавлении его обратно в экипировку.

баг исправил, он был связан с большой ошибкой, я массивы многомерные использовал как одномерные..

также у меня индекс почему-то всегда на 1 больше чем должен быть..

я понял, в C++, я часто встречался с этим и поэтому всегда писал i-1.

по сути при прокрутки цикла 1 раз, индекс равняется 1 - i == 1, а индекс в массиве заполняется index == 0.

по этой причине и стоит просто отнять 1 от i и не стоит бояться что в другом массиве i поведет себя иначе.


если ошибок больше не всплывет, в чем я уверен, потому что я собран не смотря на уталось.

То нам остается лишь написать класс умной электроники.

Идея уже готова почти, она записана в Документах на смартфоне.


-----------------------


ТАКЖЕ Я НЕ РЕАЛИЗОВАЛ КЛАСС УМНОЙ ЭЛЕКТРОНИКИ.

Как механика эта будет работать?

Для этого необходим доп пункт меню.

По сути эта механика просто работа с классом умной электроникой.

Для этого нужно также реализовать доп интерфейс.

Типа: введите IP адрес цели.

IP это типа адрес в сети, по сути сюжет такой.

Далее будет общий интерфейс для работы с электроникой.

Задача лишь получить доступ к устройству, а именно к вводу выводу.

Для этих целей я бы предложил реализовать отдельный модуль, чтобы в коде не путаться.

По сути всё очень просто.

IPv6 состоит из значений:

2001:0db8:85a3:0000:0000:8a2e:0370:7334

Далее просто нужно зашифровать в значения характеристики устройства.

Хотя я хрен знает как это будет работать и всё же это выглядит более программистки чем ID которые я использовал ранее.

Концепция должна сссылаться на доменные имена и прч.

По сути вместо IP используют домен.

Но если домена нет в базе то что делать?

Добавить.

По факту мне нужно создать интернет протокол протокол.


Концепция простая.

Есть один компьютер, есть другой.

Мне нужно создать для начала ctOS.

И её вышки, которые будут выдавать всем компьютерам уникальный ID - IP.

Чтобы подключиться к сети, нужна умная электроника - ноутбук или смартфон.

ПО сути это класс умной Электроники, который в моем распоряжении.

Это даёт мне возможность подключаться к вышкам ctOS.

Программа лишь калькулятор, она просчитывает взаимодействия между классами и игровые механики.


У меня есть класс1 и класс2.

Класс1 - это мой, класс2 - это цель.

Моя задача, сделать доступным класс2 для чтения и записи.

По сути это просто добыча информации.

Каким образом будет проходить сам взлом класса2?

Ну, мне нужно просто купить в магазине или выбить у противника ключ доступа или уязвимость.

В классе смарт электроники нужно реализовать поля  отвечающие за возможность получения доступа.

При этом доступ к полям класса, т.е должено быть как-то так:

class smart_electronics:
    network_interface = True # or False
    remote_access = True # or False
    operation_system = True # or False
    possibility_of_flashing = True # or False
    artificial_intelligence = True # or False
    connection_port = True # or False
    user_interface = True # or False
    control_panel = True # or False
    write = True # or False
    read = True # or False

тут нужно выбрать последовательность доступа к полям write read.

После чего эта цепочка будет в качестве задания.

Типа, сначала получите доступ к полю remote_access далее получите доступ к operation_system далее нужно разблокировать user_interface.

Доступ это сделать поле True.

Чтобы получить удаленный доступ нужен инструмент - …

Хотя если удаленный доступ False, то сделать его доступным не выйдет..

Тут нужно продумать логику доступа для каждого варианта умной электроники.

Единственные поля на которые может влиять игрок, это read write, остальные лишь описывают объект и определяют алгоритм получения доступа к write read.

----------

get_acces этот метод по идеи будет выдавать задания, выполняя которые я постеппено получу доступ к записи и чтению

получив доступ к которым, можно будет работать с хранилищем устройства.

класс изначально должен получать конфигурацию из файла настроек.

а поле access_lgorithm_dict хранит цепочку действий которые в конце откроют мне рид врайт.

Сценарий 1:
	network_interface = True            # имеет или не имеет выход в интернет
        remote_access = False               # имеет или не имеет удаленный доступ
        operation_system = True             # есть или нет ОС
        possibility_of_flashing = False     # возможно ли перепрошить или нет
        artificial_intelligence = False     # есть ли ИИ
        connection_port = False             # есть ли физические порты для подключения
        user_interface = True               # есть ли пользовательский интерфейс или нет(локальный или через интернет, например)
        control_panel = False               # есть ли панель управления или нет(типо физичесого терминала)
        write = False                       # доступна ли запись в storage или нет
        read = False                        # доступно ли чтение из storage или нет
    
        access_lgorithm_dict = {}
        storage = []



Имеется сервер, на нем заблокирован удаленный доступ - нужен токен, но выход в интернет есть.
Имеется ОС, а ИИ на борту нету.
Прошивка заблокированна, по причине отсутствия карты физического доступа.


Карта физического доступа lvl 1:
if control_panel == True:
connection_port = True
possibility_of_flashing = True
read = True

Карта физического доступа lvl 2:
if control_panel == True:
connection_port = True
possibility_of_flashing = True
read = True
write = True

Токен доступа lvl 1:
if remote_access == True:
read = True

Токен доступа lvl 2:
if remote_access == True:
read = True
write = True


Комментарий:
	Я думаю добавить шаблоны этого класса с готовой сюжетной электроникой.
	Но ведь есть ещё сети компьютеров.
	Например, КПП. Конечно у меня в игре этого не предуссмотренно, ведь для этого нужна локация.
	Я вижу эту систему так: мой смартфон, это смартфон как у Эйдена пирса.
	Через него я могу или не могу получить доступ к сети компьютеров целей.
	По задумки, я могу выйти в сеть лишь имея компьютер.
	Из чего следует, что мне нужно купить компьютер.
	Но давать целый класс под это.. ну фигня.
	С другой стороны, можно реализовать атаку на меня же.
	Хотя, ну его. Пойду путем которым задумал.
	Компьютеров в сети мжет быть много.
	Добавление цели идёт путем функции - добавить компьтер в сеть.
	После чего в ДНС появиться домен, который можно выбрать при подключении.
	Выбор нужного компьютера из ДНС базы мжно сделать в  виде страниц в меню.
	
	Я добавил туда дизайн протокола вд, осталось определиться с меню.
	Я думаю логично было бы сделать:
	1. Добавить устройство в сеть.
	2. Моя сеть.
	
	Я реализовал это, далее нужно реализовать первичную сеть.
	Это сложно, поэтому для начала реализую просто добавление устройства в сеть.
	У класса смарт электро можно сделать под сеть, типа словаря в котором есть побочные устройства.
	
	Но при добавлении цели, нужно ограничить игрока?
	Я думаю так сделать для того чтобы не путаться, но не думаю что это продуманное решение.
	Вот у меня есть цель, её ID у меня в Obsidian.
	Добавить цель у которой есть куча под целей будет не просто, это длинная строка закадирванных значений.
	Сложно будет такую цель создавать..
	
	Список под целей будет содержать лишь NPC, аналогично как и в Watch Dogs.
	
	...
	
	Карты доступа будут расходным материалом.
	
	name_network-interface=True_remote-access=False_operation-system=True_possibility-of-flashing=False_artificial-intelligence=False_connection-port=False_user-interface=True_control-panel=False_write=False_read=False_storage:gun_damage=100_charge=100:gun_recharge=100:access-algorithm-dict:bot_HP=100_armor=200_damage=100_strong=3_critical-dmg=45_drop-trophy:smart-card=write=True
	
	Примерно так и выглядит строка характеристик этого класса..
	
	Много и сложно, тестим декодер.
	
	Сам декодер получился слишком багованный, придёться от него отказаться.
	
	нужно сократить длину строки в 5 раз где-то.
	
	по сути можно пользовать сокращения.
	
	
	name_network-interface=True_remote-access=False_operation-system=True_possibility-of-flashing=False_artificial-intelligence=False_connection-port=False_user-interface=True_control-panel=False_write=False_read=False_storage:gun_damage=100_charge=100:gun_recharge=100:access-algorithm-dict:bot_HP=100_armor=200_damage=100_strong=3_critical-dmg=45_drop-trophy:smart-card=write=True
	

	
	Это строка полностью отличается от всех предыдущих, она короче чем была и более читаемая, : заменил на ; потому что у NPC_ID уже стоит : чтобы декодер не запутался.
	
	+ разделитель строк.
	
	готово.
	
	Ляя.. нужно реализовать отображение данных хранилища лишь при доступе к чтению.
	
	Готово.
	
	
	В целом даже для того чтобы узнать у кого есть доступ к хранилищу требуются права для чтения.
	
	
	    se.network_interface       = int(base_char_all[0][1]) # NI - network_interface
	    se.remote_access           = int(base_char_all[1][1]) # RA - remote_access
	    se.operation_system        = int(base_char_all[2][1]) # OS - operation_system
	    se.possibility_of_flashing = int(base_char_all[3][1]) # PoF - possibility_of_flashing
	    se.artificial_intelligence = int(base_char_all[4][1]) # AI - artificial_intelligence
	    se.connection_port         = int(base_char_all[5][1]) # CP - connection_port
	    se.user_interface          = int(base_char_all[6][1]) # UI - user_interface
	    se.control_panel           = int(base_char_all[7][1]) # CP2 - control_panel
	    se.write                   = int(base_char_all[8][1]) # W - write
	    se.read                    = int(base_char_all[9][1]) # R - read
	
	name_NI=1_RA=0_OS=1_PoF=0_AI=0_CP=1_UI=1_CP2=1_W=0_R=0+S;gun_damage=100_charge=100;gun_recharge=100+AAD;bot_HP=100_armor=200_damage=100_strong=3_critical-dmg=45_drop-trophy:smart-card=write=True
	
	
	
	
	Возможно стоит реализовать поиск инструмента по имени, хотя пофиг.
	
	как будет выглядеть ID копьютера:
	name_smart_electronics=1
	
	А вот так буде выглядить карта доступа:
	name_access_card_read_write
	name_access_card_read
	name_access_card_write
	
	Эти инструменты отличаются от тех что можно экипировать.
	
	Кстати, а я лечение реализовывал?
	
ПРИЛОЖЕНИЕ ГОТОВО!
	
	

        

